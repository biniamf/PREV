<!DOCTYPE html>
<!-- saved from url=(0026)https://selab.fbk.eu/PREV/ -->
<html lang="en"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script async="" src="res/unicorn.txt"></script>
    <title>PREV - a tool to security test of permission re-delegation vulnerabilities in Android apps</title>
    <!-- Meta -->
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Detecting Anomalous Sensitive Information Flows in Android Apps">
    <meta name="author" content="3rd Wave Media">    
    <link rel="shortcut icon" href="">  
    <link href="res/css" rel="stylesheet" type="text/css">
    <link href="res/css(1)" rel="stylesheet" type="text/css"> 
    <!-- Global CSS -->
    <link rel="stylesheet" href="res/bootstrap.min.css">   
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="res/font-awesome.css">
    <!-- github acitivity css -->
    <link rel="stylesheet" href="res/octicons.min.css">
    <link rel="stylesheet" href="res/github-activity-0.1.0.min.css">
    
    <!-- Theme CSS -->  
    <link id="theme-style" rel="stylesheet" href="res/styles.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="res/default.css">
    <script src="res/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head> 

<body>
    <!-- ******HEADER****** --> 
    <header class="header">
        <div class="container">                       
            <div class="profile-content pull-left">
                <h1 class="name">PREV</h1>
                <h2 class="desc">Security Testing of Permission Re-delegation Vulnerabilities in Android Apps</h2>                   
            </div><!--//profile-->                          
        </div><!--//container-->
    </header><!--//header-->
    
    <div class="container sections-wrapper">
        <div class="row">
            <div class="primary col-md-8 col-sm-12 col-xs-12">
                <section class="about section">
                    <div class="section-inner">
                        <h2 class="heading">Summary</h2>
                        <div class="content">
                         
                         <p>The Android platform facilitates reuse of app functionalities by allowing an app to request an action from another app through inter-process communication mechanism. This feature is one of the reasons for the popularity of Android, but it also poses security risks to the end users because malicious, unprivileged apps could exploit this feature to make privileged apps perform privileged actions on behalf of them.</p>
			
			<p>In this paper, we present a novel approach for precise detection of permission re-delegation vulnerabilities in Android apps. It is a hybrid approach that seamlessly and e ectively combines program analysis, test generation, natural language processing, machine learning techniques. Our approach  rst clusters a large set of benign and non-vulnerable apps based on their similarities in terms of functional descriptions. For each cluster, it then infers permission re-delegation model of the cluster that characterizes common permission re-delegation behaviors of the apps in the cluster. Given an app under test, our approach checks whether it has permission re-delegation behaviors that deviate from the model of the cluster it belongs to. If that is the case, it generates test cases to detect the vulnerabilities.</p>
			p&gt; We evaluated the vulnerability detection precision of our approach based on 1,258 o cial apps. We also compared with three static analysis-based approaches — FlowDroid, Covert, and IccTA — based on 595 open source apps. Our approach detected 30 vulnerable apps and produced zero false alarm; FlowDroid and IccTA did not detect any vulnerable app, and produced 8 and 15 false alarms, respectively; Covert detected one vulnerable app and produced 17 false alarms. Executable proof-of-concept attacks generated by our approach were reported to the corresponding app developers.<p></p>
                        </div><!--//content-->
                    </div><!--//section-inner-->                 
                </section><!--//section-->
    
                <section class="projects section">
                    <div class="section-inner">
                        <h2 class="heading">Prototype components</h2>
                        <p>These prototype components can be used separately for different purposes.</p>
                        <div class="content">
                            <div class="item">
                                <h3 class="title">Topic classification</h3>
                                <p class="summary">Topic classification is done using <a class="more-link" href="http://mallet.cs.umass.edu/" target="_blank"><i class="fa fa-external-link"></i>Mallet</a>. Though we used 30 topics, feel free to experiment with different number of topics (as the current Play Store  also has more than 30 category)</p>
                            </div><!--//item-->
                           <div class="item">
                                <h3 class="title">Clustering</h3>
                                <p class="summary">Clustering is done using <a class="more-link" href="https://www.cs.waikato.ac.nz/ml/weka/" target="_blank"><i class="fa fa-external-link"></i>Weka</a>. Expectation Maximization (EM) algorithm was used.</p>                          
                              
                            </div><!--//item-->      
                           <div class="item">
                                <h3 class="title">Cluster assignment</h3>
                                <p class="summary">Cluster assignment is done using Weka as a classification problem. Once we have assigned each training app to a cluster, whenever we have a new app to analyze (referred AUT), we perform classification to determine which cluster the app belongs to so that we can compare its behavior with apps in the corresponding cluster.  The simple Naive Bayes classifier was used.</p>
                            </div><!--//item-->                                                  
                           <div class="item">
                                <h3 class="title">API Reachability Analysis</h3>
                                <p class="summary">API reachability analysis is performed on the call graph in order to identify privileged APIs that can be reached from public entry point(s). A tool that analyzes an app and exports reachable sensitive APIs has been implemented and is available as JAR. The tool takes an APK as input and performs the reachability analysis and outputs statically reachable paths. This paths are later subject to test case generation that attempts to generate inputs that cover the reported paths.</p>
                            </div><!--//item--> 
                           <div class="item">
                                <h3 class="title">Anomalies Identification</h3>
                                <p class="summary">The anomaly identification is implemented in R and the script is available below.</p>
                            </div><!--//item-->                                                        
                            <div class="item">
                                <h3 class="title">Instrumentation</h3>
                                <p></p>The app under test is instrumented to trace method execution in order to compute the GA fitness. This is a generic tool that inserts a statement that logs method calls such as A() -&gt; B() meaning in method A, there is a call to method B. The log is also marked with tag that will be later easy to filter. This is also available as JAR.<p></p>                                
                            </div><!--//item-->
                            <div class="item">
                                <h3 class="title">Test case generation</h3>
                                <p class="summary">Once outlier paths are available, test case is generated that executes these paths. A tool that uses Genetic Algorithm has been implemented and is available as JAR. This is also a generic tool that can generate  inter-component communcation inputs (ICC) (or simply, intents). It can be used in different contex to generate ICC inputs, however, expects the app to be instrumented to log method invocations in <i>[TAG] A() -&gt; B()</i> format</p>                                
                            </div><!--//item-->
                           
                            
                            <a class="btn btn-cta-primary btn-download" href="tool/prev_tool.zip" target="_blank"><i class="fa fa-download"></i>Download tool</a>
                            
                        </div><!--//content-->  
                    </div><!--//section-inner-->                 
                </section><!--//section-->
                
                <section class="experience section">
                    <div class="section-inner">
                        <h2 class="heading">Usage</h2>
                        <div class="content">
                            <div class="item">
                                <h3 class="title">Prerequisites</h3>
                                <p>In order to be able to classify apps, we first need to have a training data. Our training data consisits of 10K+ top Google Play apps. For the classification based on topics, we need to perform the topic classification for the training apps.</p>
                                <p>Once topic classification, clustering and cluster assignment is done using Malet and Weka, we precced with the following tools.</p>
                                
                            </div><!--//item-->
                            <div class="item">
                                <h3 class="title">Modeling and outlier detection</h3>
                                <p>In this section we present the script used to create a model and then use this model to find outliers.</p>
                                <p>To learn a model from a cluster apps, we use the following R script. It produces the frequency vectory and the cut-off/threshold. It expects the list of apps in a given cluster, the list of unique 'exposed' APIs in a cluster, output filename for the average frequency vector, output filename for the threshold/cutoff value and the static analysis result of each app in the cluster.</p>
                                <p>
                                </p><pre><code class="R hljs">args = commandArgs(trailingOnly=<span class="hljs-literal">TRUE</span>)

<span class="hljs-keyword">if</span> (length(args) &lt; <span class="hljs-number">5</span>) {
  <span class="hljs-keyword">stop</span>(<span class="hljs-string">"Usage: apps_list.csv apis_in_cluster.csv ave_out_filename cutoff_filename cluster_files"</span>, 
  				call.=<span class="hljs-literal">FALSE</span>)
}

wd &lt;- getwd()

<span class="hljs-keyword">tryCatch</span>(apps &lt;- read.table(paste(wd, args[<span class="hljs-number">1</span>], sep=<span class="hljs-string">"/"</span>), header=<span class="hljs-literal">FALSE</span>, sep=<span class="hljs-string">"\n"</span>), 
					error=<span class="hljs-keyword">function</span>(e) <span class="hljs-literal">NULL</span>)
<span class="hljs-keyword">tryCatch</span>(apis &lt;- read.csv(paste(wd, args[<span class="hljs-number">2</span>], sep=<span class="hljs-string">"/"</span>), header=<span class="hljs-literal">FALSE</span>, sep = <span class="hljs-string">"\n"</span>), 
					error=<span class="hljs-keyword">function</span>(e) <span class="hljs-literal">NULL</span>)

apps.names &lt;- apps
apis.name &lt;- apis

apps.names$ID &lt;-  <span class="hljs-number">1</span>:nrow(apps)
apis.name$ID &lt;- seq.int(nrow(apis))

data &lt;- data.frame(matrix(<span class="hljs-number">0</span>, nrow(apps), nrow(apis)))

files &lt;- list.files(path=paste(wd, args[<span class="hljs-number">5</span>], sep=<span class="hljs-string">"/"</span>))
curr_dir &lt;- getwd()
setwd(paste(wd, args[<span class="hljs-number">5</span>], sep=<span class="hljs-string">"/"</span>))

rownames(data) &lt;- apps.names$ID
colnames(data) &lt;- apis.name$ID

<span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:length(files)) {
  file = files[i]
  d1 &lt;- <span class="hljs-literal">NULL</span>
  <span class="hljs-keyword">tryCatch</span>(d1 &lt;- read.table(file, header=<span class="hljs-literal">FALSE</span>, quote=<span class="hljs-string">"\""</span>, sep=<span class="hljs-string">"\n"</span>), error=<span class="hljs-keyword">function</span>(e) <span class="hljs-literal">NULL</span>)
  <span class="hljs-keyword">for</span> (anApi <span class="hljs-keyword">in</span> d1[,<span class="hljs-number">1</span>]){
    id = apis.name$ID[apis.name==as.character(anApi)]
    data[i, id] &lt;- <span class="hljs-number">1</span> 
    rm(id)
  }
  rm(anApi,d1,file)
}
rm(i)

average = rep(<span class="hljs-number">0</span>, length(apis.name$ID))
total = average
<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:length(average)){
  average[i] = mean(data[,i])
  total[i] = sum(data[,i])
}
rm(i)

distances = rep(<span class="hljs-number">0</span>, length(apps.names$ID))
<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>:length(distances)){
  distance &lt;- sqrt( sum((data[i,] - average) ^ <span class="hljs-number">2</span>) )
  distances[i] &lt;- distance
  rm(distance)
}
rm(i)

bp &lt;- boxplot(distances)

setwd(curr_dir)

<span class="hljs-comment"># output average and cutoff distance</span>
write.csv(average,paste(wd, args[<span class="hljs-number">3</span>], sep=<span class="hljs-string">"/"</span>),row.names=<span class="hljs-literal">FALSE</span>)
write.csv(bp$stats[<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], paste(wd, args[<span class="hljs-number">4</span>], sep=<span class="hljs-string">"/"</span>), row.names=<span class="hljs-literal">FALSE</span>)</code></pre>
							
							With this, we have a model of each cluster that we are interested in. 	
							<p></p>
							<p>
							Once we created a model, assuming we already performed the cluster assignment (using Weka), we perform outlier detection. We use the following R script to do outlier detection.
							</p>
							<p>
							The script expects the list of APIs used by the given app, the list of APIs in the given cluster, the average frequency vector for the cluster, the threshold for the cluster and output file.
							</p>

							<code></code><pre><code class="hljs r">args = commandArgs(trailingOnly=<span class="hljs-literal">TRUE</span>)

<span class="hljs-keyword">if</span> (length(args) &lt; <span class="hljs-number">6</span>) {
  <span class="hljs-keyword">stop</span>(<span class="hljs-string">"Usage: apps_api_usage.txt apis_in_cluster.csv average.txt cutoff.txt output_file"</span>, call.=<span class="hljs-literal">FALSE</span>)
}

wd &lt;- getwd()

cutoff &lt;- read.table(paste(wd, args[<span class="hljs-number">4</span>], sep=<span class="hljs-string">"/"</span>), header=<span class="hljs-literal">TRUE</span>, quote=<span class="hljs-string">"\""</span>, sep=<span class="hljs-string">"\n"</span>) <span class="hljs-comment"># cutoff</span>
average &lt;- read.table(paste(wd, args[<span class="hljs-number">3</span>], sep=<span class="hljs-string">"/"</span>), header=<span class="hljs-literal">TRUE</span>, quote=<span class="hljs-string">"\""</span>, sep=<span class="hljs-string">"\n"</span>) <span class="hljs-comment"># average</span>
app &lt;- args[<span class="hljs-number">1</span>] <span class="hljs-comment"># the app</span>
apis &lt;- read.table(paste(wd, args[<span class="hljs-number">2</span>], sep=<span class="hljs-string">"/"</span>), header=<span class="hljs-literal">FALSE</span>, sep = <span class="hljs-string">"\n"</span>) <span class="hljs-comment"># list of apis</span>

output_file &lt;- paste(wd, args[<span class="hljs-number">6</span>], sep=<span class="hljs-string">"/"</span>)

apps.names &lt;- data.frame(app)
apis.name &lt;- apis

apps.names$ID &lt;-  <span class="hljs-number">1</span>
apis.name$ID &lt;- seq.int(nrow(apis))

data &lt;- data.frame(matrix(<span class="hljs-number">0</span>, nrow(apps.names), nrow(apis)))

rownames(data) &lt;- apps.names$ID
colnames(data) &lt;- apis.name$ID

newAPI=<span class="hljs-number">0</span>
file = paste(wd, args[<span class="hljs-number">5</span>], sep=<span class="hljs-string">"/"</span>)<span class="hljs-comment">#toString(apps.names[1,1])</span>
d1 &lt;- read.table(file, header=<span class="hljs-literal">FALSE</span>, sep=<span class="hljs-string">"\n"</span>)
<span class="hljs-keyword">for</span> (anApi <span class="hljs-keyword">in</span> d1[,<span class="hljs-number">1</span>]){
  id = apis.name$ID[apis.name==as.character(anApi)]
  <span class="hljs-keyword">if</span> (length(data[<span class="hljs-number">1</span>, id]) != <span class="hljs-number">0</span>) {
    data[<span class="hljs-number">1</span>, id] &lt;- <span class="hljs-number">1</span> 
  }
  
  rm(id)
}
rm(anApi,file)

averages = t(average)

distance &lt;- sqrt( sum((data[<span class="hljs-number">1</span>,] - averages) ^ <span class="hljs-number">2</span>) ) <span class="hljs-comment">#tested</span>
print(paste(<span class="hljs-string">"Distance:"</span>,distance,<span class="hljs-string">"---cutoff:"</span>,cutoff,sep=<span class="hljs-string">" "</span>))

<span class="hljs-keyword">if</span> (distance &lt; as.double(cutoff) &amp;&amp; newAPI != <span class="hljs-number">1</span>) {  
  quit()
} <span class="hljs-keyword">else</span> {  
  med = median(averages[<span class="hljs-number">1</span>,])
  <span class="hljs-keyword">for</span> (anApi <span class="hljs-keyword">in</span> d1[,<span class="hljs-number">1</span>]){
    <span class="hljs-comment"># get the id of the api from the list</span>
    id = apis.name$ID[apis.name==as.character(anApi)]
    <span class="hljs-comment"># get the average value m_i of the api from the cluster</span>
    mi = averages[<span class="hljs-number">1</span>, as.numeric(id)]

    <span class="hljs-keyword">if</span> (length(mi) == <span class="hljs-number">0</span>) {
      <span class="hljs-comment"># maybe the API does not blong to the cluster</span>
      write(as.character(anApi), output_file, append=<span class="hljs-literal">TRUE</span>)
      <span class="hljs-keyword">next</span>
    }

    <span class="hljs-comment"># is the api's popularity below the median? </span>
    <span class="hljs-keyword">if</span> (mi &lt;= med) {
     <span class="hljs-comment"># write to file the api for genetic algorithm</span>
      write(as.character(anApi), output_file, append=<span class="hljs-literal">TRUE</span>)
    }
  }  
}</code></pre>
							<p>This script produces the list of anomaluous APIs in the app. The following tools are provided as JAR file.</p>
                            </div><!--//item-->

                            <div class="item">
                                <h3 class="title">Instrumentation</h3>
                                <p>Run the following command
                                </p><pre><code class="hljs r">
<span class="hljs-comment"># instrumatation </span>
java -jar instrumenter.jar input_dir/{$APK} ${platforms} output/${APK}</code></pre>
                                Where ${platforms} variable is set to the platform JAR files directory. This will produce an instrumented app. Don't forget to sign and zipalign in order to be able to install it in an emulator/device.
                                <pre><code class="hljs r">
<span class="hljs-comment">#signing the instrumented apk</span>
./signApk.sh output/${APK}
                                </code></pre>
                                <p></p>                                
                            </div><!--//item-->
                            <div class="item">
                                <h3 class="title">API Reachablity Analysis</h3>
                                <p>Run the following tool to extract the publicly reachable sensitive API 
                                </p><pre><code class="hljs r"> <span class="hljs-comment"># extracting sensive paths to sinks</span>
java -jar CallGraphAnalyzer.jar input_dir/${APK} SourcesAndSinks.txt $platforms output/${APK}_sensitive_paths.txt
</code></pre>
                                Where SourcesAndSinks.txt is an empty file (reserved for data-flow analysis). This will produce the list of path leading to reachable sensitive APIs.
                                <p></p>                                
                            </div><!--//item-->
                                                        <div class="item">
                                <h3 class="title">Test case generation</h3>
                                <p>Before running the following command, don't forget to have an emulator or a device running with the instrumented app to test already installed.
                                </p><pre><code class="hljs">java -jar GAIntentGenerator.jar output/${APK}_sensitive_paths.txt ${APK} ${platforms} ${path_to_adb}</code></pre>

                                This attempts to prodoce inputs (test cases) that execute the paths. It is configured to use 150 initial population and 500 maximum evaluations.
                                <br><br>
				NOTE: it is recommended to pass the original unmodified ${APK} instead of the one that is instrumented.
                                <p></p>                                
                            </div><!--//item-->
                        </div><!--//content-->  
                    </div><!--//section-inner-->                 
                </section><!--//section-->               
            </div><!--//primary-->   
        </div><!--//row-->
    </div><!--//masonry-->
    
    <!-- ******FOOTER****** --> 
    <footer class="footer">
        <div class="container text-center">
                <small class="copyright">Based on design by 3rd Wave Media</small>
        </div><!--//container-->
    </footer><!--//footer-->
 
    <!-- Javascript -->          
    <script type="text/javascript" src="res/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="res/jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="res/bootstrap.min.js"></script>    
    <script type="text/javascript" src="res/jquery.rss.min.js"></script> 
    <!-- github activity plugin -->
    <script type="text/javascript" src="res/mustache.min.js"></script>
    <script type="text/javascript" src="res/github-activity-0.1.0.min.js"></script>
    <!-- custom js -->
    <script type="text/javascript" src="res/main.js"></script>    

 


</body></html>
